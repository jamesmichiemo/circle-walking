<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Circle Walking</title>
    <link rel="stylesheet" href="styles.css">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 600px;
            margin: 50px auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        h1 {
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .controls {
            margin: 30px 0;
        }
        
        button {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            border: none;
            padding: 15px 30px;
            font-size: 18px;
            border-radius: 50px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .stop {
            background: linear-gradient(45deg, #f44336, #d32f2f);
        }
        
        .test {
            background: linear-gradient(45deg, #ff9800, #f57c00);
        }
        
        .status {
            margin: 20px 0;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #333;
        }
        
        .current-phrase {
            font-weight: bold;
            color: #667eea;
            font-size: 24px;
        }
        
        .countdown {
            color: #666;
            font-size: 16px;
        }
        
        .metronome-info {
            background: rgba(102, 126, 234, 0.1);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .metronome-status {
            font-size: 16px;
            color: #667eea;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .metronome-bpm {
            font-size: 14px;
            color: #666;
        }
        
        .timing-info {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }
        
        .metronome-visualizer {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #667eea;
            margin: 10px auto;
            transition: all 0.1s ease;
        }
        
        .metronome-visualizer.beat {
            transform: scale(1.3);
            background: #ff6b6b;
        }
        
        .phrases-list {
            margin-top: 30px;
            text-align: left;
        }
        
        .phrases-list h3 {
            color: #333;
            margin-bottom: 15px;
        }
        
        .phrases-list ul {
            list-style: none;
            padding: 0;
        }
        
        .phrases-list li {
            padding: 8px 15px;
            margin: 5px 0;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }
        
        .audio-status {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 8px;
            font-size: 14px;
            color: #666;
        }
        
        .error {
            color: #f44336;
        }
        
        .success {
            color: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Circle Walking</h1>
        
        <div class="controls">
            <button id="testBtn" onclick="testAudio()" class="test">Test Audio</button>
            <button id="startBtn" onclick="startPlayer()">Begin</button>
            <button id="stopBtn" onclick="stopPlayer()" class="stop" style="display: none;">Close</button>
        </div>
        
        <div class="audio-status" id="audioStatus">
            Click "Test Audio" to check if sound is working
        </div>
        
        <div class="metronome-info" id="metronomeInfo" style="display: none;">
            <div class="metronome-status" id="metronomeStatus">Metronome: Starting</div>
            <div class="metronome-bpm" id="metronomeBpm">BPM: 60</div>
            <div class="timing-info" id="timingInfo">Prompt timing: 2-20 seconds</div>
            <div class="metronome-visualizer" id="metronomeViz"></div>
        </div>
        
        <div class="status" id="status">
            Click "Begin" to start
        </div>
        
        <div class="phrases-list">
            <h3>8 Mother Palms Posture:</h3>
            <ul>
                <li>Press down</li>
                <li>Press up</li>
                <li>Hold the sky</li>
                <li>Embrace</li>
                <li>Press forward and back</li>
                <li>Point to Earth and Sky</li>
                <li>Lion holds the ball</li>
                <li>Dragon shows its claws</li> 
            </ul>
        </div>
    </div>

    <script>
        class RandomSpeechPlayer {
            constructor() {
                this.phrases = [
                    "change",
                    "dragon shows its claws",
                    "press forward and back", 
                    "point to earth and sky",
                    "embrace",
                    "hold the sky",
                    "press up",
                    "lion holds the ball",
                    "change",
                    "change",
                    "press down"
                ];
                
                this.isRunning = false;
                this.timeoutId = null;
                this.countdownInterval = null;
                this.speechSynth = window.speechSynthesis;
                this.audioContext = null;
                this.audioReady = false;
                this.speechReady = false;
                
                // Metronome properties
                this.metronomeInterval = null;
                this.currentBPM = 60;
                this.targetBPM = 60;
                this.minBPM = 45;
                this.maxBPM = 130;
                this.bpmDirection = 1; // 1 for increasing, -1 for decreasing
                this.metronomePlaying = false;
                this.sessionStartTime = 0;
                
                // Initialize audio systems
                this.initializeAudio();
            }
            
            initializeAudio() {
                // Initialize Web Audio API
                this.createBellSound();
                
                // Check speech synthesis
                this.checkSpeechSupport();
                
                // Wait for voices to load
                this.waitForVoices();
            }
            
            createBellSound() {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.audioReady = true;
                    this.updateAudioStatus();
                } catch (e) {
                    console.warn('Web Audio API not supported:', e);
                    this.audioReady = false;
                    this.updateAudioStatus('Web Audio API not supported');
                }
            }
            
            checkSpeechSupport() {
                if (this.speechSynth) {
                    this.speechReady = true;
                } else {
                    console.warn('Speech synthesis not supported');
                    this.speechReady = false;
                    this.updateAudioStatus('Speech synthesis not supported');
                }
            }
            
            waitForVoices() {
                if (this.speechSynth) {
                    const loadVoices = () => {
                        const voices = this.speechSynth.getVoices();
                        if (voices.length > 0) {
                            console.log(`${voices.length} voices available`);
                            this.speechReady = true;
                            this.updateAudioStatus();
                        }
                    };
                    
                    // Try to load voices immediately
                    loadVoices();
                    
                    // Also listen for the voices changed event
                    this.speechSynth.addEventListener('voiceschanged', loadVoices);
                }
            }
            
            updateAudioStatus(errorMsg = null) {
                const statusEl = document.getElementById('audioStatus');
                if (errorMsg) {
                    statusEl.innerHTML = `<span class="error">‚ö†Ô∏è ${errorMsg}</span>`;
                } else if (this.audioReady && this.speechReady) {
                    statusEl.innerHTML = '<span class="success">‚úÖ Audio systems ready</span>';
                } else {
                    const audioState = this.audioReady ? '‚úÖ' : '‚ùå';
                    const speechState = this.speechReady ? '‚úÖ' : '‚ùå';
                    statusEl.innerHTML = `Audio: ${audioState} | Speech: ${speechState}`;
                }
            }
            
            // Calculate dynamic timing range based on current BPM
            getTimingRange() {
                // Normalize BPM to a 0-1 scale
                const bpmProgress = (this.currentBPM - this.minBPM) / (this.maxBPM - this.minBPM);
                
                // At minBPM (45): 2-20 seconds
                // At maxBPM (130): 2-8 seconds
                // Linear interpolation
                const minSeconds = 2;
                const maxSecondsAtMin = 20;
                const maxSecondsAtMax = 8;
                
                const maxSeconds = maxSecondsAtMin - (bpmProgress * (maxSecondsAtMin - maxSecondsAtMax));
                
                return {
                    min: minSeconds,
                    max: Math.round(maxSeconds)
                };
            }
            
            updateTimingDisplay() {
                const range = this.getTimingRange();
                const timingEl = document.getElementById('timingInfo');
                if (timingEl) {
                    timingEl.textContent = `Prompt timing: ${range.min}-${range.max} seconds`;
                }
            }
            
            async playBellSound() {
                if (!this.audioContext) {
                    console.log('üîî Bell sound (Web Audio not available)');
                    this.playFallbackBeep();
                    return;
                }

                try {
                    // Resume audio context if suspended
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    const now = this.audioContext.currentTime;
                    
                    // Main bell tone
                    const osc1 = this.audioContext.createOscillator();
                    const gain1 = this.audioContext.createGain();
                    
                    osc1.connect(gain1);
                    gain1.connect(this.audioContext.destination);
                    
                    osc1.frequency.setValueAtTime(800, now);
                    osc1.frequency.exponentialRampToValueAtTime(400, now + 0.5);
                    
                    gain1.gain.setValueAtTime(0.3, now);
                    gain1.gain.exponentialRampToValueAtTime(0.01, now + 1.5);
                    
                    osc1.start(now);
                    osc1.stop(now + 1.5);
                    
                    // Harmonic
                    const osc2 = this.audioContext.createOscillator();
                    const gain2 = this.audioContext.createGain();
                    
                    osc2.connect(gain2);
                    gain2.connect(this.audioContext.destination);
                    
                    osc2.frequency.setValueAtTime(1200, now);
                    osc2.frequency.exponentialRampToValueAtTime(600, now + 0.3);
                    
                    gain2.gain.setValueAtTime(0.15, now);
                    gain2.gain.exponentialRampToValueAtTime(0.01, now + 1);
                    
                    osc2.start(now);
                    osc2.stop(now + 1);

                    console.log('üîî Bell sound played successfully');
                } catch (error) {
                    console.error('Error playing bell sound:', error);
                    this.playFallbackBeep();
                }
            }
            
            async playMetronomeTick() {
                if (!this.audioContext) {
                    return;
                }

                try {
                    // Resume audio context if suspended
                    if (this.audioContext.state === 'suspended') {
                        await this.audioContext.resume();
                    }

                    const now = this.audioContext.currentTime;
                    
                    // Create a short, sharp tick sound
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    
                    osc.frequency.setValueAtTime(1000, now);
                    
                    gain.gain.setValueAtTime(0.1, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
                    
                    osc.start(now);
                    osc.stop(now + 0.1);

                    // Update visualizer
                    const viz = document.getElementById('metronomeViz');
                    viz.classList.add('beat');
                    setTimeout(() => viz.classList.remove('beat'), 100);
                    
                } catch (error) {
                    console.error('Error playing metronome tick:', error);
                }
            }
            
            playFallbackBeep() {
                // Create a simple beep using HTML5 Audio
                try {
                    const beep = new Audio("data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFApGn+DyvmIcBjaR1/LNeSsFJHfH8N2QQAoUXrTp66hVFA==");
                    beep.volume = 0.3;
                    beep.play().catch(e => console.log('Beep failed:', e));
                } catch (e) {
                    console.log('üîî Bell (all audio failed)');
                }
            }
            
            updateMetronomeDisplay() {
                const statusEl = document.getElementById('metronomeStatus');
                const bpmEl = document.getElementById('metronomeBpm');
                
                let phase = '';
                const elapsed = Date.now() - this.sessionStartTime;
                const minutes = Math.floor(elapsed / 60000);
                
                if (this.bpmDirection > 0) {
                    phase = 'Speeding up';
                } else {
                    phase = 'Slowing down';
                }
                
                statusEl.textContent = `Metronome: ${phase} (${minutes}m)`;
                bpmEl.textContent = `BPM: ${Math.round(this.currentBPM)}`;
                
                // Update timing display
                this.updateTimingDisplay();
            }
            
            startMetronome() {
                if (this.metronomePlaying) return;
                
                this.metronomePlaying = true;
                this.sessionStartTime = Date.now();
                this.currentBPM = this.minBPM;
                this.bpmDirection = 1;
                
                document.getElementById('metronomeInfo').style.display = 'block';
                
                const tick = () => {
                    if (!this.metronomePlaying) return;
                    
                    this.playMetronomeTick();
                    
                    // Gradually adjust BPM
                    const bpmChangeRate = 0.5; // BPM change per beat
                    this.currentBPM += this.bpmDirection * bpmChangeRate;
                    
                    // Reverse direction at limits
                    if (this.currentBPM >= this.maxBPM) {
                        this.bpmDirection = -1;
                        this.currentBPM = this.maxBPM;
                    } else if (this.currentBPM <= this.minBPM) {
                        this.bpmDirection = 1;
                        this.currentBPM = this.minBPM;
                    }
                    
                    this.updateMetronomeDisplay();
                    
                    // Schedule next tick based on current BPM
                    const interval = 60000 / this.currentBPM;
                    this.metronomeInterval = setTimeout(tick, interval);
                };
                
                // Start the metronome
                tick();
            }
            
            stopMetronome() {
                this.metronomePlaying = false;
                if (this.metronomeInterval) {
                    clearTimeout(this.metronomeInterval);
                    this.metronomeInterval = null;
                }
                document.getElementById('metronomeInfo').style.display = 'none';
            }
            
            async speakPhrase(phrase) {
                if (phrase === "bell") {
                    await this.playBellSound();
                    return;
                }
                
                if (!this.speechSynth) {
                    console.log(`Speaking: ${phrase} (Speech not available)`);
                    return;
                }

                try {
                    // Cancel any ongoing speech
                    this.speechSynth.cancel();
                    
                    // Wait a moment to ensure cancel takes effect
                    await new Promise(resolve => setTimeout(resolve, 100));
                    
                    // Add a small delay before speaking to prevent cutoff
                    await new Promise(resolve => setTimeout(resolve, 200));
                    
                    const utterance = new SpeechSynthesisUtterance(phrase);
                    utterance.rate = 1;
                    utterance.pitch = 1;
                    utterance.volume = 0.8;
                    
                    // Try to use a good English voice
                    const voices = this.speechSynth.getVoices();
                    if (voices.length > 0) {
                        const englishVoice = voices.find(voice => 
                            voice.lang.startsWith('en') && !voice.name.includes('Google')
                        ) || voices.find(voice => voice.lang.startsWith('en'));
                        
                        if (englishVoice) {
                            utterance.voice = englishVoice;
                        }
                    }

                    // Add error handling
                    utterance.onerror = (event) => {
                        console.error('Speech error:', event.error);
                    };

                    utterance.onstart = () => {
                        console.log('Speaking:', phrase);
                    };
                    
                    this.speechSynth.speak(utterance);
                    
                    // Wait for speech to complete
                    return new Promise((resolve) => {
                        utterance.onend = resolve;
                        utterance.onerror = resolve;
                        // Fallback timeout
                        setTimeout(resolve, 3000);
                    });
                } catch (error) {
                    console.error('Error speaking phrase:', error);
                }
            }
            
            updateStatus(message) {
                document.getElementById('status').innerHTML = message;
            }
            
            showCountdown(seconds, phrase) {
                let remaining = seconds;
                const range = this.getTimingRange();
                
                this.updateStatus(`
                    <div class="countdown">Next in ${remaining} seconds (${range.min}-${range.max}s range)</div>
                    <div>Will play: <span class="current-phrase">${phrase === 'bell' ? 'üîî Bell sound' : phrase}</span></div>
                `);
                
                this.countdownInterval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        this.updateStatus(`
                            <div class="countdown">Next in ${remaining} seconds (${range.min}-${range.max}s range)</div>
                            <div>Will play: <span class="current-phrase">${phrase === 'bell' ? 'üîî Bell sound' : phrase}</span></div>
                        `);
                    } else {
                        clearInterval(this.countdownInterval);
                    }
                }, 1000);
            }
            
            async start() {
                if (this.isRunning) return;
                
                // Try to activate audio context first
                if (this.audioContext && this.audioContext.state === 'suspended') {
                    try {
                        await this.audioContext.resume();
                        console.log('Audio context resumed');
                    } catch (e) {
                        console.warn('Could not resume audio context:', e);
                    }
                }
                
                this.isRunning = true;
                document.getElementById('startBtn').style.display = 'none';
                document.getElementById('stopBtn').style.display = 'inline-block';
                
                // Start metronome
                this.startMetronome();
                
                // Wait a moment before starting phrases to let metronome establish
                setTimeout(() => {
                    this.scheduleNext();
                }, 2000);
            }
            
            stop() {
                this.isRunning = false;
                document.getElementById('startBtn').style.display = 'inline-block';
                document.getElementById('stopBtn').style.display = 'none';
                
                if (this.timeoutId) {
                    clearTimeout(this.timeoutId);
                    this.timeoutId = null;
                }
                
                if (this.countdownInterval) {
                    clearInterval(this.countdownInterval);
                    this.countdownInterval = null;
                }
                
                if (this.speechSynth) {
                    this.speechSynth.cancel();
                }
                
                // Stop metronome
                this.stopMetronome();
                
                this.updateStatus('Player stopped');
            }
            
            async test() {
                this.updateStatus('Testing audio systems...');
                
                // Test speech first with delay to prevent cutoff
                await this.speakPhrase('Audio test');
                
                // Wait a moment, then test bell
                setTimeout(async () => {
                    await this.playBellSound();
                    
                    // Test metronome tick
                    setTimeout(async () => {
                        await this.playMetronomeTick();
                        setTimeout(() => {
                            this.updateStatus('Audio test complete');
                        }, 1000);
                    }, 1000);
                }, 3000);
            }
            
            scheduleNext() {
                if (!this.isRunning) return;
                
                // Get current timing range based on BPM
                const timingRange = this.getTimingRange();
                
                // Random wait time within the dynamic range
                const waitTime = Math.floor(Math.random() * (timingRange.max - timingRange.min + 1)) + timingRange.min;
                
                // Select random phrase
                const phrase = this.phrases[Math.floor(Math.random() * this.phrases.length)];
                
                this.showCountdown(waitTime, phrase);
                
                this.timeoutId = setTimeout(async () => {
                    if (!this.isRunning) return;
                    
                    this.updateStatus(`
                        <div class="current-phrase">Playing: ${phrase === 'bell' ? 'üîî Bell sound' : phrase}</div>
                    `);
                    
                    await this.speakPhrase(phrase);
                    
                    // Schedule next phrase with longer delay to ensure speech completes
                    setTimeout(() => {
                        if (this.isRunning) {
                            this.scheduleNext();
                        }
                    }, 3000);
                    
                }, waitTime * 1000);
            }
        }
        
        // Global instance
        let player = new RandomSpeechPlayer();
        
        async function startPlayer() {
            await player.start();
        }
        
        function stopPlayer() {
            player.stop();
        }
        
        async function testAudio() {
            await player.test();
        }
        
        // Handle page visibility changes
        document.addEventListener('visibilitychange', function() {
            if (document.hidden && player.speechSynth) {
                player.speechSynth.cancel();
            }
        });

        // Auto-resume audio context on any user interaction
        document.addEventListener('click', async function() {
            if (player.audioContext && player.audioContext.state === 'suspended') {
                try {
                    await player.audioContext.resume();
                    console.log('Audio context resumed on click');
                } catch (e) {
                    console.warn('Failed to resume audio context:', e);
                }
            }
        });
    </script>
</body>
</html>
